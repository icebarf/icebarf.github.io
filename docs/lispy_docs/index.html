<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/fonts.css">
    
    <title>Sysgrammer</title>
    <link rel="icon" type="image/png" href="/assets/img/favicon.ico" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"
        integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
    <script src="/js/dark.js" defer=""></script>

</head>


<html>
<!DOCTYPE html>
<html>

<body>
  <header class="site-header">

    <div class="wrapper">
      <a class="muted small" href="https://sysgrammer.github.io">Sysgrammer</a>
    </div>
  </header>
</body>

</html>

<h1>Lispy Documentation</h1>
<p class="post-meta"><time itemprop="datePublished">May 18, 2021</time>
</p>
<h2 id="introduction">Introduction</h2>
<p>This webpage contains the documentation of my lisp implementation which was invented by <a href="http://theorangeduck.com/">Daniel Holden</a>. The documentation is divided into sections and the index is available after this introduction. This implementation is very different from all the typical lisps and there are some noticable differences. This guide assumes that you atleast know what Lisps are. However if you don&rsquo;t, I recommend searching about it. It is not completely necessary to understand lisps for you to use Lispy but a little knowledge won&rsquo;t do you any harm.</p>
<p>Also please note that I am in no way a Lisp expert and apologise to all of the Lisp evangelists who found mistakes due at my ignorance or lack of knowledge.</p>
<p><strong><strong>Lispy</strong></strong> is a dynamically typed interpreted language implemented in C. It is just meant for fun/tinkering language rather than being a &ldquo;work&rdquo; or &ldquo;production&rdquo; oriented language. This implementation lacks many of the useful features that make up a Programming Language. The focus here, is on the documentation so the deficiencies will be discussed in a later section.</p>
<blockquote>
<p>A pdf version is also available <a href="../lispy_docs.pdf">here</a></p>
</blockquote>
<h2 id="documentation-index">Documentation Index</h2>
<ul>
<li><a href="../../_docs/lispy_docs/#getting-started">Getting started</a>
<ul>
<li><a href="../../_docs/lispy_docs/#modes">Modes</a></li>
<li><a href="../../_docs/lispy_docs/#hello-world---scripting">Scripting Mode</a></li>
<li><a href="../../_docs/lispy_docs/#hello-world---shell">Shell Mode</a></li>
</ul>
</li>
<li><a href="../../_docs/lispy_docs/#comments">Comments</a></li>
<li><a href="../../_docs/lispy_docs/#operators">Operators</a>
<ul>
<li><a href="../../_docs/lispy_docs/#mathematical-operators">Mathematical Operators</a></li>
<li><a href="../../_docs/lispy_docs/#relational-operators">Relational Operators</a></li>
<li><a href="../../_docs/lispy_docs/#logical-operators">Logical Operators</a></li>
</ul>
</li>
<li><a href="../../_docs/lispy_docs/#variables">Variables</a>
<ul>
<li><a href="../../docs/lispy_docs/#function-aliasing">Function Aliasing</a></li>
</ul>
</li>
<li><a href="../../_docs/lispy_docs/#an-important-difference">S-Expr Vs. Q-Expr</a></li>
<li><a href="../../_docs/lispy_docs/#functions">Functions</a>
<ul>
<li><a href="../../_docs/lispy_docs/#list-functions">List Functions</a></li>
<li><a href="../../_docs/lispy_docs/#user-defined-functions">User Defined Functions</a></li>
</ul>
</li>
<li><a href="../../_docs/lispy_docs/#conditionals">Conditionals</a></li>
<li><a href="../../_docs/lispy_docs/#output--file-loading-in-shell-mode-and-scripts">Output and Command Line Arguments</a>
<ul>
<li><a href="../../_docs/lispy_docs/#println">Println</a></li>
<li><a href="../../_docs/lispy_docs/#error">Error</a></li>
<li><a href="../../_docs/lispy_docs/#loading">Loading</a></li>
</ul>
</li>
<li><a href="../../_docs/lispy_docs/#standard-library">Standard Library</a></li>
<li><a href="../../_docs/lispy_docs/#deficiencies-as-a-programming-language">Deficiencies</a></li>
<li><a href="../../_docs/lispy_docs/#conclusion">Conclusion</a></li>
<li><a href="../../_docs/lispy_docs/#references">References</a></li>
</ul>
<h2 id="getting-started">Getting started</h2>
<h3 id="modes">Modes</h3>
<p>Lispy can be in two modes &ndash; shell and scripting. Shell mode is one where you all code is executed per line like the Python interpreter. Scripting mode is where you execute <code>lispy</code> binary with a file having extension <code>.bsf</code>. The Following section will give some examples:</p>
<h3 id="hello-world---scripting">Hello World - Scripting</h3>
<p>A standard hello world program looks like this in lispy.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(println <span style="color:#e6db74">&#34;Hello, World!&#34;</span>)
</code></pre></div><p>Then we store above text in a file called <code>hello.bsf</code> and then we run it using the following command.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lispy hello.bsf
</code></pre></div><p>and the output should give us</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#e6db74">&#34;Hello, World!&#34;</span>
</code></pre></div><h3 id="hello-world---shell">Hello World - Shell</h3>
<p>In the shell mode first we execute lispy</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lispy
Lispy version 1.0.2
Press CTRL + C to exit
&gt;&gt;&gt; 
</code></pre></div><p>This is the output you should get. After this we&rsquo;re going to print hello world using <code>println</code> builtin</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">&gt;&gt;&gt; <span style="color:#f92672">(</span>println <span style="color:#e6db74">&#34;Hello, World!&#34;</span><span style="color:#f92672">)</span>
<span style="color:#e6db74">&#34;Hello, World!&#34;</span>
<span style="color:#f92672">()</span>
</code></pre></div><p>Note that in shell mode, <code>()</code> indicates success.</p>
<p>Another thing to be noted is that <code>(println &quot;Hello, World!&quot;)</code>in shell mode, is the same as, <code>println &quot;Hello, World!&quot;</code>. The parentheses or brackets can be omitted in shell mode. However this is note true for scripting mode and you must include the parentheses <code>()</code> in your scripts.</p>
<h2 id="comments">Comments</h2>
<p>Lines starting with<code>semi-colon</code>( <code>;</code>) are comments in the lisp. These lines are ignored by the interpreter</p>
<p>For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#75715e">; This will print &#34;X doesnt equal to y&#34;</span>
(def {x y} <span style="color:#ae81ff">24</span> <span style="color:#ae81ff">23</span>)
(<span style="color:#66d9ef">if</span> (== x y) 
  {println <span style="color:#e6db74">&#34;X equals to y&#34;</span>}
{println <span style="color:#e6db74">&#34;X doesnt equal to y&#34;</span>}) 
</code></pre></div><p>In the above example, the line after the semi-colon is ignored and does not affect the code at all and is meant to provide readability only.</p>
<h2 id="operators">Operators</h2>
<p>The operators in lispy follow polish notation i.e they come before their operands. For example, To add two numbers we must do</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; (add <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">4.00000</span>
</code></pre></div><p>or</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; (<span style="color:#a6e22e">+</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">4.00000</span>
</code></pre></div><h3 id="mathematical-operators">Mathematical Operators</h3>
<p>There are 8 arithmetic operators and the following table shows the comprehensive list of mathematical operators in lispy.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Name</th>
<th>Alt name</th>
<th>Usage</th>
<th>Return Value Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Addition</td>
<td>add</td>
<td>+</td>
<td>(add 2 2)</td>
<td>S-expression</td>
</tr>
<tr>
<td>Subtraction</td>
<td>sub</td>
<td>-</td>
<td>(sub 6 2)</td>
<td>S-expression</td>
</tr>
<tr>
<td>Multiplication</td>
<td>mul</td>
<td>*</td>
<td>(mul 23 9)</td>
<td>S-expression</td>
</tr>
<tr>
<td>Division</td>
<td>div</td>
<td>/</td>
<td>(/ 26 2)</td>
<td>S-expression</td>
</tr>
<tr>
<td>Remainder  / Modulus</td>
<td>rem</td>
<td>%</td>
<td>(% 26 2)</td>
<td>S-expression</td>
</tr>
<tr>
<td>Power</td>
<td>pow</td>
<td>^</td>
<td>(^ 4 5)</td>
<td>S-expression</td>
</tr>
</tbody>
</table>
<p>Please note that <code>Name</code> and <code>Alt name</code> of operators can be used interchangeably.</p>
<h3 id="relational-operators">Relational Operators</h3>
<p>There are 8 relational operators and the following table shows the comprehensive list Relation operators in lispy.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Name</th>
<th>Alt name</th>
<th>Usage</th>
<th>Return Value Type</th>
<th>Return values</th>
</tr>
</thead>
<tbody>
<tr>
<td>Greater than</td>
<td>&gt;</td>
<td>NA</td>
<td>(&gt; 10 2)</td>
<td>S-expression</td>
<td>1.00000 if true <!-- raw HTML omitted -->0.00000 if false</td>
</tr>
<tr>
<td>Lesser than</td>
<td>&lt;</td>
<td>NA</td>
<td>(&lt; 4 7)</td>
<td>S-expression</td>
<td>1.00000 if true <!-- raw HTML omitted -->0.00000 if false</td>
</tr>
<tr>
<td>Greater than or equals to</td>
<td>&gt;=</td>
<td>NA</td>
<td>(&gt;= 23 9)</td>
<td>S-expression</td>
<td>1.00000 if equal or greater <!-- raw HTML omitted -->0.00000 if false</td>
</tr>
<tr>
<td>Lesser than or equals to</td>
<td>&lt;=</td>
<td>NA</td>
<td>(&lt;= 24 56)</td>
<td>S-expression</td>
<td>1.00000 if equal or lesser <!-- raw HTML omitted -->0.00000 if false</td>
</tr>
<tr>
<td>Comparison (Equals to)</td>
<td>==</td>
<td>NA</td>
<td>(== 24 24)</td>
<td>S-expression</td>
<td>1.00000 if true <!-- raw HTML omitted -->0.00000 if false</td>
</tr>
<tr>
<td>Comparison (does not  equals to)</td>
<td>!=</td>
<td>NA</td>
<td>(!= 24 23)</td>
<td>S-expression</td>
<td>1.00000 if true <!-- raw HTML omitted -->0.00000 if false</td>
</tr>
<tr>
<td>Minimum</td>
<td>min</td>
<td>NA</td>
<td>(min 4 2 8 21 45)</td>
<td>S-expression</td>
<td>Minimum number in input</td>
</tr>
<tr>
<td>Maximum</td>
<td>max</td>
<td>NA</td>
<td>(max 4 5 6 23 65)</td>
<td>S-expression</td>
<td>Maximum number in input</td>
</tr>
</tbody>
</table>
<h3 id="logical-operators">Logical Operators</h3>
<p>Please note that these operators are not defined in the core lispy language, These are a part of the Lispy Standard Library. I won&rsquo;t be going into much detail about the library.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Usage</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>(and 0 1) or<!-- raw HTML omitted -->(and 1 0) or<!-- raw HTML omitted -->(and 1 1)</td>
<td>Logical AND</td>
</tr>
<tr>
<td>or</td>
<td>(or 0 1) or<!-- raw HTML omitted -->(or 1 0) or<!-- raw HTML omitted -->(or 1 1)</td>
<td>Logical OR</td>
</tr>
<tr>
<td>not</td>
<td>(not 2)</td>
<td>Logical not</td>
</tr>
</tbody>
</table>
<h2 id="variables">Variables</h2>
<p>Variables are quite interestingly implemented in this lisp version. The variables and functions are defined in two environments &ndash; Parent and Child. The Parent environment contains all the builtin functions and variables etc. The lisp first checks if the user input within Parent environment and if it is there, it calls that functions or displays that variable. However if it is not, Then it goes to child environment and again checks if there is a user defined function or variables there and then calls/displays it. Again if it is not there, It then defines the variable with the input from user and if some variable was already present, Its value is replaced with the newer one. There is another interesting feat. due to this Parent-Child structure that we will talk about sooner in this section.</p>
<p>Now, onto user defined variables. Variables can be defined using the <code>def</code> keyword or builtin.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return value</th>
</tr>
</thead>
<tbody>
<tr>
<td>def</td>
<td>(def {num} 25)</td>
<td>Defines a userspace variable Takes a quote-expression first argument then a s-expr, q-expr, or a string</td>
<td>() on success</td>
</tr>
</tbody>
</table>
<p>Some examples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#75715e">; A number as a variable</span>
&gt;&gt;&gt; (def {num} <span style="color:#ae81ff">25</span>)
()
&gt;&gt;&gt; <span style="color:#75715e">;Printing the variable now</span>
&gt;&gt;&gt; num
<span style="color:#ae81ff">25.00000</span>

<span style="color:#75715e">; A string as a variable</span>
&gt;&gt;&gt; (def {name_string} <span style="color:#e6db74">&#34;My Name&#34;</span>)
()
&gt;&gt;&gt; name_string
<span style="color:#e6db74">&#34;My Name&#34;</span>

<span style="color:#75715e">; A Q-expression / List as a variable</span>
&gt;&gt;&gt; (def {list} {2 <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> 7})
()
&gt;&gt;&gt; <span style="color:#a6e22e">list</span>
{2 <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> 7}

<span style="color:#75715e">; Assigning a variable to a variable</span>
&gt;&gt;&gt; (def {num} name_string)
()
&gt;&gt;&gt; num
<span style="color:#e6db74">&#34;My Name&#34;</span>
</code></pre></div><h3 id="function-aliasing">Function Aliasing</h3>
<p>The <code>def</code> keyword can also be used to rename builtin functions as something else. This is due to the Parent-Child environment structure that was described earlier.</p>
<p>For example, We can alias <code>mul</code> as <code>add-n-times</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; (def {add-n-times} mul)
()
&gt;&gt;&gt; add-n-times <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">4.00000</span>
&gt;&gt;&gt; add-n-times <span style="color:#ae81ff">24</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">72.00000</span>
</code></pre></div><p>As you can see, function aliasing is quite interesting and can be used to name large sets of instructions into a more compact and readable form. This is the end of this section, Moving on&hellip;</p>
<p>The above examples should make it pretty clear on how to use variables. Before we jump into functions, I would here like to clear up the difference between a S-expr and Q-expr before we dive into the depth of functions (Well they&rsquo;re not that deep&hellip;.)</p>
<h2 id="an-important-difference">An Important Difference</h2>
<p>If you&rsquo;ve been following along the documentation until now, and you&rsquo;re unfamiliar with lisps. You must be wondering what exactly is the difference between <strong>S-expr and Q-expr</strong>. If you were smart enough and have read some examples, you must&rsquo;ve already figured something out and that is a Q-expr is just a list. And if you did, then congratulations! You are correct. Lisps internally store their source code and data as lists and that is one of the reasons why they&rsquo;re so powerful, their ability to mix source code with data is amazing, However what I said isn&rsquo;t exactly the way things work.</p>
<h3 id="s-expr">S-Expr</h3>
<p>The syntax is always enclosed in parentheses <code>()</code> as you may have observed. S-expressions are just a nested list of data and that data may be syntax, variables, input, q-expr, or nested s-expr themselves. The atoms and cons cells aren&rsquo;t implemented in a typical way in Lispy as they are in a &ldquo;typical lisp&rdquo;. It is a huge tree with a lot of branches and then they have nodes and then nodes themselves have branches. In context to lispy, you may want to read <a href="http://buildyourownlisp.com/chapter7_evaluation">Chapter-7</a> of BuildYourOwnLisp where Daniel explains the inner structure of the tree/s-expressions.</p>
<h3 id="q-expr">Q-Expr</h3>
<p>Q-expressions, enclosed in curly brackets are a form of data type, a list. The list itself may contain nested lists, strings, numbers. Another thing to note here is that instead of using <code>commas</code> &ndash; <code>,</code> to separate values, we use spaces, this helps in saving a lot of character space internally in the buffer and the result is almost identical with the same readability as commas.</p>
<h2 id="functions">Functions</h2>
<p>There are many useful builtin functions in lispy. There are some functions described in the Standard Library of Lispy as well but we will not be taking a look at the standard library for quite a while. This time we will be describing functions one-by-one instead of making a small table. Earlier operators need not much explaining as they quite speak for themselves but the same is sometimes not true for the functions defined in the lisp.</p>
<h3 id="list-functions">List Functions</h3>
<h4 id="list">List</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>(list 14 23 12 56 &ldquo;hello_world&rdquo;)</td>
<td>Convert data to Q-expr or list</td>
<td>Q-expr</td>
</tr>
</tbody>
</table>
<h4 id="head">Head</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>head</td>
<td>head {14 23 12 56}</td>
<td>Get the first element of a Q-expr</td>
<td>Q-expr</td>
</tr>
</tbody>
</table>
<h4 id="tail">Tail</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>tail</td>
<td>tail {14 23 12 56}</td>
<td>Deletes the first element from Q-expr and returns the remaining data as it is.</td>
<td>Q-expr</td>
</tr>
</tbody>
</table>
<h4 id="join">Join</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>join</td>
<td>join {14 23 12 56} {43 12 67}</td>
<td>Join two Q-expr and return them combined.</td>
<td>Q-expr</td>
</tr>
</tbody>
</table>
<h4 id="eval">Eval</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>eval {println &ldquo;Hello, World!&quot;}</td>
<td>Take a Q-expr and evaluate it as a S-expr.</td>
<td>S-expr</td>
</tr>
</tbody>
</table>
<p>The above function might be hard to understand so let me interject for a moment and explain how it works, as the description says, it evaluates lists or q-expressions. Normally, If <code>{println &quot;hello, World!&quot;}</code> were a normal q-expr i.e without <code>eval</code>. It would have just been a normal q-expr of length 2 and its content would remain untouched unless explicitly done with List functions. Its contents would not have been evaluated.</p>
<p>With the <code>eval</code>function, it gets evaluated. Another example</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; <span style="color:#a6e22e">eval</span> {tail {23 <span style="color:#ae81ff">25</span> 26}}
{25 26}
</code></pre></div><h4 id="cons">Cons</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>cons</td>
<td>cons 21 {22 23 24 25}</td>
<td>Takes a value and a q-expr and appends the value to front.</td>
<td>Q-expr</td>
</tr>
</tbody>
</table>
<h4 id="len">Len</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>len</td>
<td>len {12 12 32 215 76 45}</td>
<td>Takes a Q-expr as argument and returns the length of expression</td>
<td>Integer</td>
</tr>
</tbody>
</table>
<h4 id="init">Init</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>init</td>
<td>init {12 12 32 215 76 45}</td>
<td>Takes a Q-Expr and removes the last element from it</td>
<td>Q-expr</td>
</tr>
</tbody>
</table>
<p>Above all concludes the builtin list functions of Lispy.</p>
<h2 id="user-defined-functions">User Defined Functions</h2>
<p>We can define our own functions using the <code>fun</code> function. It is defined in the standard library. There is also another way of defining user-functions using the <code>\</code> or <code>lambda</code> function that is built into the lisp.  We won&rsquo;t be going into much detail about lambda functions here but I will explain it briefly and show an example then move to the more easier and readable form of defining functions using <code>fun</code>.</p>
<h3 id="lambda">Lambda</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>(\ {x y} {* x y}</td>
<td>Lambda function takes two q-expr as arguments, the first is the formal arguments the 2nd is the function body.</td>
<td>lambda function</td>
</tr>
</tbody>
</table>
<p>As you can see, to define a function that takes two arguments and multiplies them, we use the above code. Then to call it we have to reuse the above code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; (\ {x y} {* x y}) <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>
<span style="color:#ae81ff">200.00000</span>
</code></pre></div><p>As you can see readability is quite hard and there is a lot of redundant code. Then we can name it using the <code>def</code> keyword described earlier.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; def {mul} (\ {x y} {+ x y})
</code></pre></div><p>Then we can just call it by its name along with its arguments</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; mul <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>
</code></pre></div><p>This method defining functions is quite tedious and repetitive and hard to read. Therefore the standard library has a function <code>fun</code> which allows the user to define other functions.</p>
<h3 id="fun">Fun</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>fun</td>
<td>(fun {mul x y} {* x y}</td>
<td>Defines a function. Takes two q-expr arguments. First one is function name and formal arguments. First argument must have function name as the first member of q-expr then the variables. The 2nd argument is function body.</td>
<td>lambda function</td>
</tr>
</tbody>
</table>
<p>The function takes two q-expr arguments same as lambda and then defines a function in child environment.</p>
<p>Using fun requires you to <code>load</code> the standard library which is present in <code>/usr/bin/stdlib.bsf</code>. It can be loaded with <code>load &quot;/usr/bin/stdlib.bsf&quot;</code> on top of the file. <code>load</code> function will be described in the later sections.</p>
<p>The fun function is implemented as following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; fun
&gt;&gt;&gt; (\ {f b} {def (head f) (\ (tail f) b)})
</code></pre></div><h2 id="conditionals">Conditionals</h2>
<h3 id="if">If</h3>
<p>if is a conditional statement, part of Lispy. It is described briefly:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>(if (== x y) <!-- raw HTML omitted -->  <!-- raw HTML omitted -->{println &ldquo;X equals to y}<!-- raw HTML omitted --><!-- raw HTML omitted -->{println &ldquo;X doesnt equal to y}</td>
<td>Takes 2 arguments and 1 optional argument.<!-- raw HTML omitted --><!-- raw HTML omitted -->First argument is a S-Expr and is the condition for if statement<!-- raw HTML omitted --><!-- raw HTML omitted -->Second argument is a Q-Expr which are the statements to be executed.<!-- raw HTML omitted --><!-- raw HTML omitted -->Third argument is optional and the else part of the if statement.<!-- raw HTML omitted -->It is also a Q-Expr.</td>
<td></td>
</tr>
</tbody>
</table>
<p>The else statement is implicit and is not explicitly defined in the language. It is always the statement that follows the first <code>{}</code> Q-expr.</p>
<p>Example: Store the following in a <code>test.bsf</code> file</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#75715e">; This will print &#34;X equals to y&#34;</span>
(def {x y} <span style="color:#ae81ff">23</span> <span style="color:#ae81ff">23</span>)
(<span style="color:#66d9ef">if</span> (== x y) 
  {println <span style="color:#e6db74">&#34;X equals to y&#34;</span>}
{println <span style="color:#e6db74">&#34;X doesnt equal to y&#34;</span>}) 
</code></pre></div><p>Then we run it with</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lispy test.bsf
<span style="color:#e6db74">&#34;X equals to y&#34;</span>
</code></pre></div><p><strong>Else Example:</strong></p>
<p>Store the following in a <code>test.bsf</code> file</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#75715e">; This will print &#34;X doesnt equal to y&#34;</span>
(def {x y} <span style="color:#ae81ff">24</span> <span style="color:#ae81ff">23</span>)
(<span style="color:#66d9ef">if</span> (== x y) 
  {println <span style="color:#e6db74">&#34;X equals to y&#34;</span>}
{println <span style="color:#e6db74">&#34;X doesnt equal to y&#34;</span>}) 
</code></pre></div><p>Then we run it with</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ lispy test.bsf
<span style="color:#e6db74">&#34;X doesn&#39;t equal to y&#34;</span>
</code></pre></div><h2 id="output--file-loading-in-shell-mode-and-scripts">Output &amp; File loading in shell mode and scripts</h2>
<p>Lispy has two builtin functions defined in it which allow to send output to the user. The Functions are <code>println</code> and <code>error</code>. As from the names it is quite clear what their purpose is. Both functions are described briefly here.</p>
<h3 id="println">Println</h3>
<p>This function prints each argument separated by a space and then prints a newline character to finish. It returns the empty expression.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(def {x y} <span style="color:#ae81ff">23</span> <span style="color:#ae81ff">23</span>)
(<span style="color:#66d9ef">if</span> (== x y) 
  {println <span style="color:#e6db74">&#34;X equals to y&#34;</span>}
</code></pre></div><p>If we run above code using <code>lispy</code>, The line X equals to y will be printed.</p>
<h4 id="printing-variables">Printing variables</h4>
<p>We can print variables using the <code>println</code> statement. We can simply just give it a name of the variable and it will print it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; def {num1} <span style="color:#ae81ff">2</span>
()
&gt;&gt;&gt; println num1
<span style="color:#ae81ff">2.00000</span>

<span style="color:#75715e">; Variable operations or one liners</span>
&gt;&gt;&gt; println (<span style="color:#a6e22e">/</span> num1 <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">1.00000</span>
()
</code></pre></div><h3 id="error">Error</h3>
<p>This builtin is meant to return errors to the user in case anything goes wrong during the execution. Its syntax is very similar to <code>println</code>. It takes a string as argument and prints it if the control flow reaches the error statement.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(def {x y} <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">2</span>)
(<span style="color:#66d9ef">if</span> (== (% x y) <span style="color:#ae81ff">0</span>)
  {println <span style="color:#e6db74">&#34;x / y is true&#34;</span>}
{error <span style="color:#e6db74">&#34;X is not divisible by Y&#34;</span>})
</code></pre></div><h3 id="loading">Loading</h3>
<p>Exisitng Lispy code can be loaded into the present running environment using <code>load</code> function. Here is a brief table:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
<th>Return Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>load</td>
<td>load &ldquo;/usr/bin/stdlib.bsf&rdquo;</td>
<td>Takes a single string argument which should be a file or a file path.<!-- raw HTML omitted -->Then the code is loaded into the present running environment.</td>
<td></td>
</tr>
</tbody>
</table>
<p>Loading the standard library into the current environment:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#75715e">; Script mode</span>
(<span style="color:#a6e22e">load</span> <span style="color:#e6db74">&#34;/usr/bin/stdlib.bsf&#34;</span>)

<span style="color:#75715e">; Freely use stdlib functions now.</span>
</code></pre></div><ul>
<li>Shell mode</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">&gt;&gt;&gt; <span style="color:#a6e22e">load</span> <span style="color:#e6db74">&#34;/usr/bin/stdlib.bsf&#34;</span>
<span style="color:#75715e">; freely use stdlib in shell mode</span>
</code></pre></div><h2 id="standard-library">Standard Library</h2>
<p>The Lispy standard library is present in <code>/usr/bin</code> directory. It is named <code>stdlib.bsf</code> and it contains various definitions of useful functions. These functions are not a part of core <code>lispy</code> and lispy can very well function without these.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Usage</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>(and 0 1) or<!-- raw HTML omitted -->(and 1 0) or<!-- raw HTML omitted -->(and 1 1)</td>
<td>Logical AND</td>
</tr>
<tr>
<td>or</td>
<td>(or 0 1) or<!-- raw HTML omitted -->(or 1 0) or<!-- raw HTML omitted -->(or 1 1)</td>
<td>Logical OR</td>
</tr>
<tr>
<td>not</td>
<td>(not 2)</td>
<td>Logical not</td>
</tr>
<tr>
<td>nil</td>
<td>(println nil)</td>
<td>Empty {}</td>
</tr>
<tr>
<td>false</td>
<td>(println false)</td>
<td>Defined as 0</td>
</tr>
<tr>
<td>true</td>
<td>(println true)</td>
<td>Defined as 1</td>
</tr>
<tr>
<td>fun</td>
<td>(fun {mul x y}<!-- raw HTML omitted -->{* x y}</td>
<td>Defines functions</td>
</tr>
<tr>
<td>unpack</td>
<td>(unpack + {1 2 3 4})</td>
<td>Appends operator to Q-expr<!-- raw HTML omitted -->then evaluates the Q-expr</td>
</tr>
<tr>
<td>pack</td>
<td>(pack tail 1 2 3 4)</td>
<td>Takes a function and some arguments.<!-- raw HTML omitted -->Converts arguments to Q-expr and applies function.</td>
</tr>
<tr>
<td>curry</td>
<td>(curry + {1 2 3 4})</td>
<td>Same as unpack, different name</td>
</tr>
<tr>
<td>uncurry</td>
<td>(pack tail 1 2 3 4)</td>
<td>Same as pack, different name</td>
</tr>
<tr>
<td>flip</td>
<td>(flip div 12 2)</td>
<td>Takes one function as argument and then two arguments on which the function will perform<!-- raw HTML omitted -->However, before the function runs, the input order is switched.</td>
</tr>
<tr>
<td>ghost</td>
<td>(ghost + 2 2)</td>
<td>Does absolutely nothing. Stays in front of expressions and like a ghost. Not interacting<!-- raw HTML omitted -->with anything.</td>
</tr>
<tr>
<td>comp</td>
<td>(comp tail head {1 2 3 4}</td>
<td>Takes two functions as arguments and then another argument to the last function. The last argument<!-- raw HTML omitted -->is passed to 2nd functino and then the resulting argument is passed onto the function</td>
</tr>
<tr>
<td>fst</td>
<td>(fst {1 2 3 4})</td>
<td>Actually extracts the first element of the list. In form of a usable value S-expr instead Q-expr</td>
</tr>
<tr>
<td>snd</td>
<td>(snd {1 2 3 4})</td>
<td>Same as above except 2nd element</td>
</tr>
<tr>
<td>trd</td>
<td>(trd {1 2 3 4})</td>
<td>Same as above except 3rd element</td>
</tr>
<tr>
<td>nth</td>
<td>(nth 3 {1 2 3 4})</td>
<td>Takes two arguments. First is the position and 2nd is the list. Extracts the position element from<!-- raw HTML omitted -->list</td>
</tr>
<tr>
<td>last</td>
<td>(last {1 2 3 4})</td>
<td>Returns last element of list</td>
</tr>
<tr>
<td>take</td>
<td>(take 3 {1 2 3 4})</td>
<td>Takes two arguments. First is position and 2nd is the list. Removes the position element.</td>
</tr>
<tr>
<td>drop</td>
<td>(drop 3 {1 2 3 4 5})</td>
<td>Takes two arguments. First is position and 2nd is the list. Drops elements until position.</td>
</tr>
<tr>
<td>split</td>
<td>(split 3 {1 2 3 4 5 6 7}</td>
<td>Takes two arguments. First is position and 2nd is the list. Splits the list at position.</td>
</tr>
<tr>
<td>elem</td>
<td>(elem 2 {2 4 5 6}</td>
<td>Takes two arguments. First is a value and 2nd is list. Compares the value with all elements of list.<!-- raw HTML omitted -->If found, returns 1<!-- raw HTML omitted -->else, return 0</td>
</tr>
<tr>
<td>map</td>
<td>(map println {&ldquo;hello&rdquo; &ldquo;World&rdquo;})</td>
<td>Takes two arguments. First is a function and 2nd may be any expression. Then it maps the function to<!-- raw HTML omitted -->each element of expression.</td>
</tr>
<tr>
<td>filter</td>
<td>(filter (\ {x} {&gt; x 2}) {5 2 11 3 -4 1})</td>
<td>Takes two arguments. First is a functional condition. A functional condition is a condition in form of<!-- raw HTML omitted -->a function. Second is a list. It takes the condition and compares with each element of function. And then<!-- raw HTML omitted -->return a Q-expr where condition was true.</td>
</tr>
<tr>
<td>foldl</td>
<td>(fun {sum l} {foldl + 0 l})</td>
<td>Supplied with a function f, a base value z and a list l<!-- raw HTML omitted -->Each element is of list l is merged with base value z. The merging is dependent upon the function specified.<!-- raw HTML omitted -->When the merging is done, The elements are merged with themselves. Note that merging means applying the supplied<!-- raw HTML omitted -->function.</td>
</tr>
<tr>
<td>select</td>
<td>select    {(== i 0)  &ldquo;st&rdquo;}    <!-- raw HTML omitted -->          {(== i 1)  &ldquo;nd&rdquo;}    <!-- raw HTML omitted -->          {(== i 3)  &ldquo;rd&rdquo;}<!-- raw HTML omitted -->          {otherwise &ldquo;th&rdquo;}</td>
<td>takes in zero or more two-element lists as input. For each two element <!-- raw HTML omitted -->list in the arguments it first evaluates the first element of the pair. <!-- raw HTML omitted -->If this is true then it evaluates and returns the second item, otherwise<!-- raw HTML omitted --> it performs the same thing again on the rest of the list.</td>
</tr>
<tr>
<td>case</td>
<td>(case x<!-- raw HTML omitted -->    {0 &ldquo;Monday&rdquo;}<!-- raw HTML omitted -->    {1 &ldquo;Tuesday&rdquo;}<!-- raw HTML omitted -->    {2 &ldquo;Wednesday&rdquo;}<!-- raw HTML omitted -->    {3 &ldquo;Thursday&rdquo;}<!-- raw HTML omitted -->)</td>
<td>Similar to C switch statements. Takes a constant value and variable q-exprs. Compares and returns values.</td>
</tr>
<tr>
<td>Fibonacci</td>
<td>(fib n)</td>
<td>Prints n number of fibonacci Sequence.</td>
</tr>
</tbody>
</table>
<h2 id="deficiencies-as-a-programming-language">Deficiencies as a Programming Language</h2>
<ul>
<li>
<p>Lack of types or Type-lessness</p>
</li>
<li>
<p>Currently lispy wraps only native C <code>double</code> and <code>char*</code> types for computation.</p>
</li>
<li>
<p>No Loops</p>
</li>
<li>
<p>Lack of user defined types</p>
</li>
<li>
<p>Difference of syntax and other implementations from standard/classic lisps</p>
</li>
<li>
<p>Lack of operating system interaction</p>
</li>
<li>
<p>Garbage Collection</p>
</li>
<li>
<p>Pool Allocation (much use of malloc)</p>
</li>
<li>
<p>Variable hastable (linear search of variables in environment is currently in use)</p>
</li>
<li>
<p>Static Typing</p>
</li>
<li>
<p>Lexical Scoping</p>
</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Well this concludes our guide like documentation. I have tried to keep everything simple and clear. If you don&rsquo;t understand any part of it be sure to contact me. This took me complete <strong>7+ hours</strong> of constant screen time to write all the documentation. I don&rsquo;t know if anyone will read this part or it&rsquo;ll just remain on some dark corner of the internet. Anyways, I had much fun writing this documentation. I hope you learnt something from it or just wanted to use lispy. This was a long and tiring task. After this I&rsquo;m gonna write some makefiles for lispy and push the changes and hope everything works out.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://buildyourownlisp.com/">BuildYourOwnLisp</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp Wikipedia</a></li>
<li>My old readme</li>
</ul>


<footer>
    <div>
        <h3><a href="https://sysgrammer.github.ioposts">Back to all posts</a></h3>
    </div>
    <hr>
    <p>Go <a href="https://sysgrammer.github.io/index.xml">here</a> for an RSS feed.</p>
</footer>

</html>