<!DOCTYPE html>
<html lang="en-US"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=37551&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="The case of a few bytes
I&rsquo;ve been working on a small hobby project/program of mine. It implements image rotation
by some angle (in degrees). It&rsquo;s an exercise in Igor Zhirkov&rsquo;s book where the reader is to
use bitmap format to write back the rotated image, the input is also expected to be a bitmap image.
Anyhow, the bitmap file header begins with a 2 byte
number that identifies the BMP and DIB header. It is commonly 0x424d (BM in ascii, 0x4d42 in little endian,
how it shall appear on my machine and probably yours as well.)">  

  <title>
    
      FILE seek-ing routine details
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  
  
  
  <link rel="stylesheet" href="/css/main.da84ac9efb233b0db2baf507f3271d09a5da384a9d81507ea7e4bbb9fbf1bbb19d2ee0b5840060c2b39cdd713d062b62d4ce6e1ee97a5174685105f384844c33.css" integrity="sha512-2oSsnvsjOw2yuvUH8ycdCaXaOEqdgVB&#43;p&#43;S7ufvxu7GdLuC1hABgwrOc3XE9Biti1M5uHul6UXRoUQXzhIRMMw==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">å®¶</a>


<article>
    <p class="post-meta">
        <time datetime="2023-02-17 09:07:45 &#43;0530 IST">
            2023-02-17
        </time>
    </p>

    <h1>FILE seek-ing routine details</h1>

    
        <aside  class="toc" >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#the-case-of-a-few-bytes">The case of a few bytes</a></li>
    <li><a href="#results">Results</a></li>
    <li><a href="#why-is-this-happening">Why is this happening?</a></li>
    <li><a href="#a-better-way-to-do-things">A better way to do things</a>
      <ul>
        <li><a href="#bitmap-file-header">Bitmap File header</a></li>
        <li><a href="#device-independent-bitmap-bitmapinfoheader">Device-Independent Bitmap (BITMAPINFOHEADER)</a></li>
      </ul>
    </li>
    <li><a href="#too-long-didnt-read">Too Long didn&rsquo;t read</a></li>
    <li><a href="#footnotes">Footnotes</a></li>
  </ul>
</nav>
        </aside>
    

    <h2 id="the-case-of-a-few-bytes">The case of a few bytes</h2>
<p>I&rsquo;ve been working on a small hobby project/program of mine. It implements image rotation
by some angle (in degrees). It&rsquo;s an exercise in Igor Zhirkov&rsquo;s book where the reader is to
use bitmap format to write back the rotated image, the input is also expected to be a bitmap image.</p>
<p>Anyhow, the bitmap <a href="#bitmap-file-header">file header</a> begins with a 2 byte
number that identifies the BMP and DIB header. It is <strong>commonly</strong> <code>0x424d</code> (<code>BM</code> in ascii, <code>0x4d42</code> in little endian,
how it shall appear on my machine and probably yours as well.)</p>
<p>Now, the first approach I decided on was to read the first two bytes and compare those two bytes with <code>0x42</code> and <code>0x4d</code>
and then parse the header fully if we have the matching subset, else we don&rsquo;t parse.
During this, we need to return back to the start of the stream so we can collect the file header in one full <code>fread()</code>
call rather than manually setting our structure&rsquo;s type field<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> and then <code>fread()</code> another few bytes
into our <code>header</code> structure<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>Here are some examples of the three cases. A few details and error checking have been omitted for brevity.</p>
<ul>
<li><code>ungetc()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#ee82ee">short</span> <span style="color:#ee82ee">int</span> byte1, byte2;
</span></span><span style="display:flex;"><span>    byte1 = <span style="color:#ff0">fgetc</span>(bitmap);
</span></span><span style="display:flex;"><span>    byte2 = <span style="color:#ff0">fgetc</span>(bitmap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span>(byte1 != &#39;<span style="color:#f60">0x42</span>&#39; &amp;&amp; byte2 != &#39;<span style="color:#f60">0x4d</span>&#39;) { <span style="color:#0f0">/* do not parse further */</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">/* what we care about */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff0">ungetc</span>(byte2, bitmap);
</span></span><span style="display:flex;"><span>    <span style="color:#ff0">ungetc</span>(byte1, bitmap); <span style="color:#0f0">// probably check for eof because only 1 push back is guaranteed
</span></span></span></code></pre></div><p>Do note that with this approach only one push back is guaranteed as specified in the standard. Although, the
<a href="https://en.cppreference.com/w/c/io/ungetc#Notes">cppreference&rsquo;s</a> notes section indicates that on popular operating systems
the pushback buffer is large enough to support our operations.</p>
<blockquote>
<p>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</p></blockquote>
<blockquote>
<p>The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).</p></blockquote>
<ul>
<li><code>fseek()</code> to stream start</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#ee82ee">short</span> <span style="color:#ee82ee">int</span> byte1, byte2;
</span></span><span style="display:flex;"><span>    byte1 = <span style="color:#ff0">fgetc</span>(bitmap);
</span></span><span style="display:flex;"><span>    byte2 = <span style="color:#ff0">fgetc</span>(bitmap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span>(byte1 != &#39;<span style="color:#f60">0x42</span>&#39; &amp;&amp; byte2 != &#39;<span style="color:#f60">0x4d</span>&#39;) { <span style="color:#0f0">/* do not parse further */</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">/* what we care about */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff0">fseek</span>(bitmap, <span style="color:#f60">0</span>, SEEK_SET);
</span></span></code></pre></div><ul>
<li><code>rewind()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#ee82ee">short</span> <span style="color:#ee82ee">int</span> byte1, byte2;
</span></span><span style="display:flex;"><span>    byte1 = <span style="color:#ff0">fgetc</span>(bitmap);
</span></span><span style="display:flex;"><span>    byte2 = <span style="color:#ff0">fgetc</span>(bitmap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span>(byte1 != &#39;<span style="color:#f60">0x42</span>&#39; &amp;&amp; byte2 != &#39;<span style="color:#f60">0x4d</span>&#39;) { <span style="color:#0f0">/* do not parse further */</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">/* what we care about */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff0">rewind</span>(bitmap)
</span></span></code></pre></div><p>Now, the question that arises, which is faster? Well the obvious thing is to benchmark this, so I
rolled up my little <code>get_time_nsec()</code><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> function and measured the time it took for both cases and calculated the delta.
I ran the benchmark 10 times and then took the average, the code was compiled with these compiler options.<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<p>Before I reveal the results, make a guess. Which is faster? I asked the same question to two of my friends and both agreed
that it should be <code>fseek()</code>, (at the time, the choice for <code>rewind()</code> was not presented to them).
For the sake of keeping this article short, I shall not discuss the logic behind their arguments.</p>
<h2 id="results">Results</h2>
<ul>
<li><code>ungetc()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>ungetc_avg = (<span style="color:#f60">791</span>+<span style="color:#f60">1793</span>+<span style="color:#f60">1002</span>+<span style="color:#f60">1012</span>+<span style="color:#f60">1393</span>+<span style="color:#f60">1002</span>+<span style="color:#f60">1303</span>+<span style="color:#f60">1583</span>+<span style="color:#f60">1022</span>+<span style="color:#f60">972</span>)/<span style="color:#f60">10</span>
</span></span><span style="display:flex;"><span>ungetc_avg
</span></span><span style="display:flex;"><span><span style="color:#f60">1187.3</span>
</span></span></code></pre></div><ul>
<li><code>fseek()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>fseek_avg = (<span style="color:#f60">3396</span>+<span style="color:#f60">2936</span>+<span style="color:#f60">3326</span>+<span style="color:#f60">3356</span>+<span style="color:#f60">1834</span>+<span style="color:#f60">3576</span>+<span style="color:#f60">2855</span>+<span style="color:#f60">1783</span>+<span style="color:#f60">3056</span>+<span style="color:#f60">2285</span>)/<span style="color:#f60">10</span>
</span></span><span style="display:flex;"><span>fseek_avg
</span></span><span style="display:flex;"><span><span style="color:#f60">2840.3</span>
</span></span></code></pre></div><ul>
<li><code>rewind()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>rewind_avg = (<span style="color:#f60">4749</span>+<span style="color:#f60">2374</span>+<span style="color:#f60">5657</span>+<span style="color:#f60">5727</span>+<span style="color:#f60">4819</span>+<span style="color:#f60">4889</span>+<span style="color:#f60">6216</span>+<span style="color:#f60">6146</span>+<span style="color:#f60">5657</span>+<span style="color:#f60">6984</span>)/<span style="color:#f60">10</span>
</span></span><span style="display:flex;"><span>rewind_avg
</span></span><span style="display:flex;"><span><span style="color:#f60">5321.8</span>
</span></span></code></pre></div><blockquote>
<p>The units for these numbers is <code>ns</code> or <code>nanosecond</code>.</p></blockquote>
<p>This indicates that in this particular case, <code>ungetc()</code> is about 58.19% faster than <code>fseek()</code><sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> and 77.68% faster than <code>rewind()</code><sup id="fnref1:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>.</p>
<p>From the presented options, it seems that going a little off-standard is worth this micro-optimization but I do not recommend it, as there
is better alternative to doing the above shenanigans. Although, this benchmark does have its issues, e.g includes time taken for
function calls but it does showcase a pretty large difference for a specific case.</p>
<h2 id="why-is-this-happening">Why is this happening?</h2>
<ul>
<li><code>fseek()</code></li>
</ul>
<p>Let us take a look at glib source for <code>fseek()</code>. Upon inspection, it is defined as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">int</span>
</span></span><span style="display:flex;"><span><span style="color:#ff0">fseek</span> (FILE *fp, <span style="color:#ee82ee">long</span> <span style="color:#ee82ee">int</span> offset, <span style="color:#ee82ee">int</span> whence)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ee82ee">int</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">CHECK_FILE</span> (fp, -<span style="color:#f60">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_acquire_lock</span> (fp);
</span></span><span style="display:flex;"><span>  result = <span style="color:#ff0">_IO_fseek</span> (fp, offset, whence);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_release_lock</span> (fp);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Looking for <code>_IO_fseek()</code> results in finding out that it is a macro that actually calls <code>_IO_seekoff_unlocked()</code> that further calls <code>_IO_seekoff()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#e5e5e5">#define _IO_fseek(__fp, __offset, __whence) \
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">  (_IO_seekoff_unlocked (__fp, __offset, __whence, _IOS_INPUT|_IOS_OUTPUT) \
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">   == _IO_pos_BAD ? EOF : 0)
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">off64_t</span>
</span></span><span style="display:flex;"><span><span style="color:#ff0">_IO_seekoff_unlocked</span> (FILE *fp, <span style="color:#ee82ee">off64_t</span> offset, <span style="color:#ee82ee">int</span> dir, <span style="color:#ee82ee">int</span> mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (dir != _IO_seek_cur &amp;&amp; dir != _IO_seek_set &amp;&amp; dir != _IO_seek_end)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#ff0">__set_errno</span> (EINVAL);
</span></span><span style="display:flex;"><span>      <span style="color:#f00">return</span> EOF;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#0f0">/* If we have a backup buffer, get rid of it, since the __seekoff
</span></span></span><span style="display:flex;"><span><span style="color:#0f0">     callback may not know to do the right thing about it.
</span></span></span><span style="display:flex;"><span><span style="color:#0f0">     This may be over-kill, but it&#39;ll do for now. TODO */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (mode != <span style="color:#f60">0</span> &amp;&amp; ((<span style="color:#ff0">_IO_fwide</span> (fp, <span style="color:#f60">0</span>) &lt; <span style="color:#f60">0</span> &amp;&amp; <span style="color:#ff0">_IO_have_backup</span> (fp))
</span></span><span style="display:flex;"><span>		    || (<span style="color:#ff0">_IO_fwide</span> (fp, <span style="color:#f60">0</span>) &gt; <span style="color:#f60">0</span> &amp;&amp; <span style="color:#ff0">_IO_have_wbackup</span> (fp))))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f00">if</span> (dir == _IO_seek_cur &amp;&amp; <span style="color:#ff0">_IO_in_backup</span> (fp))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	  <span style="color:#f00">if</span> (<span style="color:#ff0">_IO_vtable_offset</span> (fp) != <span style="color:#f60">0</span> || fp-&gt;_mode &lt;= <span style="color:#f60">0</span>)
</span></span><span style="display:flex;"><span>	    offset -= fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;
</span></span><span style="display:flex;"><span>	  <span style="color:#f00">else</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#ff0">abort</span> ();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>      <span style="color:#f00">if</span> (<span style="color:#ff0">_IO_fwide</span> (fp, <span style="color:#f60">0</span>) &lt; <span style="color:#f60">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff0">_IO_free_backup_area</span> (fp);
</span></span><span style="display:flex;"><span>      <span style="color:#f00">else</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff0">_IO_free_wbackup_area</span> (fp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> <span style="color:#ff0">_IO_SEEKOFF</span> (fp, offset, dir, mode);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, it seems that <code>fseek()</code> acquires a lock and calls <code>_IO_seekoff_unlocked()</code> is calculating
a bunch of stuff regarding the <code>backup buffer</code> it seems. And then finally calling <code>_IO_SEEKOFF()</code>.
This <code>fseek()</code> call seems to involve calculations and management of a buffer, and locks in order
to go back to the beginning of the stream. This is a possible reason as to why it might be slow.</p>
<blockquote>
<p>Thanks to cortexauth#6190 for pointing me here.</p></blockquote>
<ul>
<li><code>rewind()</code>
After going through the source similarly at glibc, it is following the same pattern as <code>fseek()</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">void</span>
</span></span><span style="display:flex;"><span><span style="color:#ff0">rewind</span> (FILE *fp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">CHECK_FILE</span> (fp, );
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_acquire_lock</span> (fp);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_rewind</span> (fp);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_clearerr</span> (fp);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_release_lock</span> (fp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#e5e5e5">#define _IO_rewind(FILE) \
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">  (void) _IO_seekoff_unlocked (FILE, 0, 0, _IOS_INPUT|_IOS_OUTPUT)
</span></span></span></code></pre></div><p>Where <code>rewind()</code> is also calling <code>_IO_seekoff_unlocked()</code> but with the offset and the stream position indicators being <code>0</code> and <code>0</code> respectively.
However, <code>rewind()</code> was actually slower than <code>fseek()</code> and that might be explained by what <code>_IO_clearerr()</code> might be doing which causes it to be
additionally slower than <code>fseek()</code>. But wait! <code>_IO_clearerr()</code> is actually a macro that modifies the <code>FILE</code> structure. It seems to be masking off
the error bits.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#e5e5e5">#define _IO_clearerr(FP) ((FP)-&gt;_flags &amp;= ~(_IO_ERR_SEEN|_IO_EOF_SEEN))
</span></span></span></code></pre></div><p>So what is the actual reason behind this slow down with <code>rewind()</code>? It could likely be the backup buffer mentioned in the source code, which is
being free&rsquo;d. Take note that in the <code>ungetc()</code> example written above, there was a note from cppreference which indicated a pushback buffer
for the stream which might actually be coming into play with <code>_IO_seekoff_unlocked()</code>&rsquo;s backup buffer here. It could likely be the same buffer(verification needed).
But then it should have been in effect when using <code>fseek()</code> as well. <code>rewind()</code> and <code>fseek()</code> should perform similar if not equally here in my opinion.</p>
<blockquote>
<p>Perhaps a more experienced reader could email me about this if they know more.</p></blockquote>
<ul>
<li><code>ungetc()</code></li>
</ul>
<p>Now, for our fastest contender <code>ungetc()</code> seems to be having a rather simple implementation. There is some minimal error checking and for
&ldquo;putting back the character on the stream&rdquo; it is just performing checks if the previous character in stream is the same character passed
as argument and then just decrements the <code>FILE</code> internal read counter/stream indicator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">int</span>
</span></span><span style="display:flex;"><span><span style="color:#ff0">ungetc</span> (<span style="color:#ee82ee">int</span> c, FILE *fp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ee82ee">int</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">CHECK_FILE</span> (fp, EOF);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (c == EOF)
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> EOF;
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (!<span style="color:#ff0">_IO_need_lock</span> (fp))
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> <span style="color:#ff0">_IO_sputbackc</span> (fp, (<span style="color:#ee82ee">unsigned</span> <span style="color:#ee82ee">char</span>) c);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_acquire_lock</span> (fp);
</span></span><span style="display:flex;"><span>  result = <span style="color:#ff0">_IO_sputbackc</span> (fp, (<span style="color:#ee82ee">unsigned</span> <span style="color:#ee82ee">char</span>) c);
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">_IO_release_lock</span> (fp);
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">int</span>
</span></span><span style="display:flex;"><span><span style="color:#ff0">_IO_sputbackc</span> (FILE *fp, <span style="color:#ee82ee">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ee82ee">int</span> result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base
</span></span><span style="display:flex;"><span>      &amp;&amp; (<span style="color:#ee82ee">unsigned</span> <span style="color:#ee82ee">char</span>)fp-&gt;_IO_read_ptr[-<span style="color:#f60">1</span>] == (<span style="color:#ee82ee">unsigned</span> <span style="color:#ee82ee">char</span>)c)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      fp-&gt;_IO_read_ptr--;
</span></span><span style="display:flex;"><span>      result = (<span style="color:#ee82ee">unsigned</span> <span style="color:#ee82ee">char</span>) c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  <span style="color:#f00">else</span>
</span></span><span style="display:flex;"><span>    result = <span style="color:#ff0">_IO_PBACKFAIL</span> (fp, c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00">if</span> (result != EOF)
</span></span><span style="display:flex;"><span>    fp-&gt;_flags &amp;= ~_IO_EOF_SEEN;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Above 8 code snippets (indicated by different code blocks) are directly taken from glibc source, their licensing applies these snippets respectively.</p></blockquote>
<p>And there you have it! We finally have <em>some grasp</em> over why <code>rewind()</code> and <code>fseek()</code> are slower than <code>ungetc()</code> in our specific case.</p>
<h2 id="a-better-way-to-do-things">A better way to do things</h2>
<h3 id="bitmap-file-header">Bitmap File header</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> <span style="color:#ff0">__attribute</span>((packed)) BitmapFileHeader
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    u16 bf_type;
</span></span><span style="display:flex;"><span>    u32 bf_fsize;
</span></span><span style="display:flex;"><span>    u32 bf_reserved;
</span></span><span style="display:flex;"><span>    u32 bf_pixels_offset;
</span></span><span style="display:flex;"><span>} <span style="color:#0f0">// 14-bytes
</span></span></span></code></pre></div><h3 id="device-independent-bitmap-bitmapinfoheader">Device-Independent Bitmap (BITMAPINFOHEADER)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> <span style="color:#ff0">__attribute</span>((packed)) BitmapInfoHeader_DIB
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    u32 bi_size;
</span></span><span style="display:flex;"><span>    i32 bi_width;
</span></span><span style="display:flex;"><span>    i32 bi_height;
</span></span><span style="display:flex;"><span>    u16 bi_panes;
</span></span><span style="display:flex;"><span>    u16 bi_bitcount;
</span></span><span style="display:flex;"><span>    u32 bi_compression;
</span></span><span style="display:flex;"><span>    u32 bi_sizeimage;
</span></span><span style="display:flex;"><span>    u32 bi_xpixels_permeter;
</span></span><span style="display:flex;"><span>    u32 bi_ypixels_permeter;
</span></span><span style="display:flex;"><span>    u32 bi_clrused;
</span></span><span style="display:flex;"><span>    u32 bi_clrimportant;
</span></span><span style="display:flex;"><span>} <span style="color:#0f0">// 54-bytes
</span></span></span></code></pre></div><p>The previously described niche case is unrealistic and should not be used in real code.
Since we know that the bitmap file header i.e the the first 14-bytes are all the same, we could perform a read
of 14-bytes and fill out the file header, and then perform the check on <code>bf_type</code> and then parse the rest of DIB (Device-Independent Bitmap) header.</p>
<p>But there is another problem here, the DIB header has many versions with variying sizes, eg.
<code>BITMAPCOREHEADER</code> (the oldest) is 12 bytes but <code>BITMAPINFOHEADER</code> (most common) is 54 bytes, and <code>OS22XBITMAPHEADER</code> adds
additional 24 bytes to the <code>BITMAPINFOHEADER</code>.</p>
<p>So we know the kind of mess we&rsquo;ve got ourselves into. The subset that I have chosen to implement in my program is <code>BM</code> for file header type
and <code>BITMAPINFOHEADER</code> structure for the in-memory DIB. The goal is to only allow <code>BITMAPINFOHEADER</code> to be parsed (and optionally support others
in the future).</p>
<p>The initial 12-bytes of all DIB headers is the same (which is actually the <code>BITMAPCOREHEADER</code>), thus it is reasonable to perform another read
of 12-bytes and then conditionally parse the rest of the header based (similar to how it was done earlier<sup id="fnref1:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>) on <code>bi_size</code> field of the header.
This way we minimize fiddling with the stream and be done in about 3 or fewer reads.
Minimizing the number of reads is important so what we should ideally do is to have a packed struct with the file header and DIB header combined
and read 14 + 12 = 26 bytes in one read, perform the checks on <code>bf_type</code> and <code>bi_size</code> and report any errors if unsuccessful otherwise continue
parsing the rest of <code>BITMAPINFOHEADER</code><sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>. Ofcourse, this advice is limited to the subset that was defined earlier. You may want to do things differently.</p>
<h2 id="too-long-didnt-read">Too Long didn&rsquo;t read</h2>
<p>Considering <a href="#the-case-of-a-few-bytes">The case of a few bytes</a> first, and then after the previous analysis,
the following conclusions can be drawn.</p>
<ul>
<li><code>ungetc()</code> is about 58.19% faster than <code>fseek()</code><sup id="fnref2:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> and 77.68% faster than <code>rewind()</code><sup id="fnref3:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>.</li>
<li><code>ungetc()</code> only modifies the internal structure of <code>FILE</code> and performs some checks.</li>
<li><code>fseek()</code> and <code>rewind()</code> are a lot more involved, calling many internal functions
for acquiring locks, performing checks on pointers, handling a buffer etc.</li>
</ul>
<p>If you&rsquo;re parsing bitmap images and want to only support the most common sub-format in BMP format, then</p>
<ul>
<li>Perform a read of 26 bytes, check for file type and dib header size.<sup id="fnref1:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></li>
<li>parse further eg. the pixel array or the color profiles or the extra bit masks when there is specific case of compression of pixel data.</li>
<li>Be done with it.</li>
</ul>
<p><em>and remember,</em> always minimize the number of reads or poking with the file stream.</p>
<p>The case described in the beginning was a naive approach.</p>
<p>Please <a href="mailto:sysgrammer@proton.me">email me</a> if you wish to discuss these results with me, I would be delighted for any kind of feedback.
This is mostly a study based on my specific case with a better approach highlighted above.</p>
<h2 id="footnotes">Footnotes</h2>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><code>header-&gt;bf_type = (byte2 &lt;&lt; 8) | byte1</code> or  if you read into a <code>short int</code> then simply <code>header-&gt;bf_type = id</code> perhaps&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Let us define an exemplary header</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> <span style="color:#ff0">__attribute</span>((packed)) BITMAPHEADER {
</span></span><span style="display:flex;"><span>    u16 bf_type;
</span></span><span style="display:flex;"><span>    u32 bf_fsize;
</span></span><span style="display:flex;"><span>    u32 bf_reserved;
</span></span><span style="display:flex;"><span>    u32 bf_pixels_offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">/* rest of the fields in the header */</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Since we&rsquo;ve manually set bf_type field already, we need to read into the structure from <code>bf_fsize</code> field.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ff0">fread</span> (&amp;header-&gt;bf_fsize, <span style="color:#f60">1</span>, <span style="color:#f00">sizeof</span>(header) - <span style="color:#f00">sizeof</span>(header-&gt;bf_type), bitmap);
</span></span></code></pre></div>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
<li id="fn:3">
<p>Benchmark</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#ee82ee">long</span>
</span></span><span style="display:flex;"><span><span style="color:#ff0">get_time_nsec</span> (<span style="color:#ee82ee">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#ifndef ICE_DONT_BENCHMARK_CODE
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span><span style="color:#f00">struct</span> timespec time;
</span></span><span style="display:flex;"><span><span style="color:#f00">if</span> (<span style="color:#ff0">timespec_get</span> (&amp;time, TIME_UTC) == <span style="color:#f60">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#ff0">fprintf</span> (stdout,<span style="color:#87ceeb">&#34;Error: Filling timespec structure failed with timespec_get()</span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#f00">return</span> time.tv_nsec;
</span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span>}
</span></span></code></pre></div>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
<li id="fn:4">
<p><code>-Wall -Wextra -Werror -O3</code>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><code>((original_value - new_value) / original_value) * 100 = X%</code>.
Increaese/Decrease depends on whether the <code>original_value</code> was larger/smaller respectively.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref2:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref3:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>Parsing the bitmap header in two reads. Error checking and some details have been omitted for the sake of brevity.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> <span style="color:#ff0">__attribute</span> ((packed)) BITMAP_HEADER
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    u16 bf_id;
</span></span><span style="display:flex;"><span>    u32 bf_fsize;
</span></span><span style="display:flex;"><span>    u32 bf_reserved;
</span></span><span style="display:flex;"><span>    u32 bf_pixels_offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    u32 bi_size;
</span></span><span style="display:flex;"><span>    i32 bi_width;
</span></span><span style="display:flex;"><span>    i32 bi_height;
</span></span><span style="display:flex;"><span>    u16 bi_panes;
</span></span><span style="display:flex;"><span>    u16 bi_bitcount;
</span></span><span style="display:flex;"><span>    u32 bi_compression;
</span></span><span style="display:flex;"><span>    u32 bi_sizeimage;
</span></span><span style="display:flex;"><span>    u32 bi_xpixels_permeter;
</span></span><span style="display:flex;"><span>    u32 bi_ypixels_permeter;
</span></span><span style="display:flex;"><span>    u32 bi_clrused;
</span></span><span style="display:flex;"><span>    u32 bi_clrimportant;
</span></span><span style="display:flex;"><span>}; <span style="color:#0f0">// 54-bytes
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00">struct</span> BITMAP_HEADER*
</span></span><span style="display:flex;"><span><span style="color:#ff0">read</span>(FILE* bitmap)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f00">struct</span> BITMAP_HEADER *metadata = <span style="color:#ff0">calloc</span>(<span style="color:#f60">1</span>, <span style="color:#f00">sizeof</span>(*metadata));
</span></span><span style="display:flex;"><span>    <span style="color:#ff0">fread</span>(data, <span style="color:#f60">1</span>, <span style="color:#f60">26</span>, bitmap);
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span>(metadata-&gt;bf_id != <span style="color:#f60">0x4d42</span>) <span style="color:#0f0">// little-endian machine, use switch if you wish to support multiple formats or something
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        ...             <span style="color:#0f0">// or perhaps do some macro magic, dealer&#39;s choice
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">if</span>(metadata-&gt;bi_size != <span style="color:#f60">40</span>)
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> metadata;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
</ol>
</div>

</article>

                
    
    
        <hr>
<p>ãµã¤ãã«æ¥ã¦ããã¦ãããã¨ããããã¾ãï¼</p>
<p>Amrit Handa</p>
<p><a href="mailto:ice@rdseed.in">ice@rdseed.in</a></p>

    


            </div>
        </main>
    </body>
</html>
